[ { "title": "(EN) Clean Code | Naming things", "url": "/posts/naming-things/", "categories": "CS, clean-code", "tags": "en, udemy", "date": "2022-11-21 03:33:00 +0000", "snippet": "These are notes from the Clean Code course by Udemy.01. Naming: Assigning good namesWhy good names matter Names should be meaningful because: It allows readers to understand the code without going through it in detail. const user = new User();database.insert(user);if (isLoggedIn) {...} Choosing good names variables, constants They are data containers. (e.g.) user input data, validation results, a list of products Use nouns or short phrases with adjectives (e.g.) const userData = {...} const isValid = {...} functions &amp; methods commands or calculated values (e.g.) send data to server, check if user input is valid Use verbs or short phrases with adjectives (e.g.) sendData() inputIsValid() classes Use classes to create “things” (e.g.) a user, a product, a HTTP request body Use nouns or short phrases with nouns (e.g.) class User {...} class RequestBody {...} Name casing snake_case: is_valid, send_response (e.g. Python - variables, functions, methods) camelCase: isValid, sendResponse (e.g. Java, JavaScript - variables, functions, methods) PascalCase: AdminRole, UserRepository (e.g. Python, Java, JavaScript - classes) kebab-case: &lt;side-bar&gt; (e.g. HTML - custom HTML elements)Naming variables &amp; properties (theory) If a value is an object, Name it to describe the value (e.g. user, database) Provide more details without introducing redundancy (e.g. authenticatedUser, sqlDatabase) If a value is a number or a string, Name it to describe the value (e.g. name, age) Provide more details without introducing redundancy (e.g. firstName) If value is a Boolean, Name it to answer a true/false question (e.g. isActive, loggedIn) Provide more details without introducing redundancy (e.g. isActiveUser, loggedIn) Naming variables &amp; properties (examples) To store a user object (i.e. name, email, age) u, data &lt; userData, person &lt; user, customer To store a user input validation result (i.e. true, false) v, val &lt; correct, validatedInput &lt; isCorrect, isValid Naming functions &amp; methods (theory) If a function performs an operation, Name it to describe the operation. (e.g. getUser(...), response.send()) Provide more details without introducing redundancy (e.g. getUserByEmail(...), response.send()) If a function computes a boolean, Name it to answer a true/false question. (e.g. isValid(...), purchase.isPaid()) Provide more details without introducing redundancy (e.g. emailIsValid(), purchase.isPaid()) Naming functions &amp; methods (examples) To save user data to a database, process, handle &lt; save, storeData &lt; saveUser, user.store To describe a function to validate the user input, process, save &lt; validateSave, check &lt; validate, isValid Naming classes (theory) Name it to describe the objects (e.g. User, Product) Provide more details without introducing redundancy (e.g. Customer, Course) Avoid redundant suffixes (e.g. DatabaseManagerNaming classes (example) To describe a user object, class UEntity, ObjA &lt; class UserObj, AppUser &lt; class User, Admin To describe a database, class Data, DataStorage &lt; class Db, Data &lt; class Database, SQLDatabase Common errors &amp; pitfalls Don’t include redundant information in names (e.g.) userWithNameAndAge = User(\"Max\", 31) &lt; user = User(\"Max\", 31) Avoid slang, unclear abbreviations &amp; disinformation Slang product.diePlease() &lt; product.remove() user.facePalm() &lt; user.sendErrorMessage() Unclear abbreviations message(n) &lt; message(newUser) ymdt = \"20210121CET &lt; dateWithTimeZone =20210121CET` Disinformation userList = {u1: ... u2: ...} &lt; userMap = {u1: ... u2: ...} allAccounts = accounts.filter() &lt; filteredAccounts = accounts.filter() Choose distinctive names Be consistent getUsers(), fetchUsers, retrieveUsers() You can go with either of those options, but stick with it throughout your entire program. Demo bad name examples from datetime import datetimeclass Entity: def __init__(self, title, description, ymdhm): self.title = title self.description = description self.ymdhm = ymdhmdef output(item): print('Title: ' + item.title) print('Description: ' + item.description) print('Published: ' + item.ymdhm)summary = 'Clean Code Is Great!'desc = 'Actually, writing Clean Code can be pretty fun. You\\'ll see!'new_date = datetime.now()publish = new_date.strftime('%Y-%m-%d %H:%M')item = Entity(summary, desc, publish)output(item) clean name examples from datetime import datetimeclass BlogPost:\tdef __init__(self, title, description, date_published):\t\tself.title = title\t\tself.description = description\t\tself.date_published = date_publisheddef print(self):\t print('Title: ' + self.title) print('Description: ' + self.description) print('Published: ' + self.date_published)title = 'Clean Code Is Great!'description = 'Actually, writing Clean Code can be pretty fun. You\\'ll see!'now = datetime.now()formatted_date = now.strftime('%Y-%m-%d %H:%M')blog_post = BlogPost(title, description, formatted_date)blog_post.print() " }, { "title": "(EN) DataCamp | Foundations for efficiencies", "url": "/posts/foundations-for-efficiencies/", "categories": "Programming, python", "tags": "en, datacamp", "date": "2022-08-08 03:33:00 +0000", "snippet": "These are notes from the Writing Efficient Python Code course by DataCamp.1. What is efficientIn general, efficient Python code is the one: executing quickly for the task at hand minimizing the memory footprint following Python’s coding style principles (i.e. PEP)2. Building with built-insPython built-in componentsBuilt-in components are referred as the Python Standard Library, and the library comes with every Python installation.Some built-in components include: Built-in types (e.g., list, tuple, set) Built-in functions (e.g., print(), len(), range()) Built-in modules (e.g., os, sys, itertools)Built-ins have been optimized to work within the Python language itself, so using them is recommended if exists.Useful built-ins: range()It returns a sequence of the given number between the given range.Syntax range(start, stop, step)Parameters start: an integer specifying at which position to start (default: 0) stop: element at which numbers in sequence have to end (exclusive) step: an integer specifying the incrementation (default: 1)Return valueThe sequence of the given number between the given rangeExample# Create a list of people that arrived at a party we're hosting.names = ['Jerry', 'Kramer', 'Elaine', 'George', 'Newman']# Create an empty list to store the indexed list.indexed_names = []# Use a for loop to get the indexed list.for i in range(len(names)): index_name = (i, names[i]) indexed_names.append(index_name)print(indexed_names)# output[(0, 'Jerry'), (1, 'Kramer'), (2, 'Elaine'), (3, 'George'), (4, 'Newman')]Useful built-ins: enumerate()It takes a collection and returns it as an indexed object.Syntax enumerate(iterable, start = 0)Parameters iterable: an iterable object start: an integer specifying the start number of the enumerate object (default: 0)Example# Create an empty list to store the indexed list.indexed_names = []# Rewrite the for loop to use enumeratefor i, name in enumerate(names): index_name = (i, name) indexed_names.append(index_name)# Rewrite the above for loop using list comprehensionindexed_names_comp = [(i, name) for i, name in enumerate(names)]# Unpack an enumerate object with a starting index of oneindexed_names_unpack = [*enumerate(names, start = 1)]print(indexed_names_unpack)# output [(1, 'Jerry'), (2, 'Kramer'), (3, 'Elaine'), (4, 'George'), (5, 'Newman')]Useful built-ins: map()It returns a map object of the results after applying the given function to each item of a given iterable.Syntax map(function, iterable)Parameters function: the function to execute for each item iterable: a sequenceExample# Create a list of people that arrived at a party we're hosting.names = ['Jerry', 'Kramer', 'Elaine', 'George', 'Newman']names_uppercase = []# Use a for loop to convert all the letters in each name to uppercase.for name in names: names_uppercase.append(name.upper())# Use a map function to convert each letter to uppercase.names_map = map(str.upper, names)# Unpack names_map into a listnames_uppercase = [*names_map]3. The power of NumPy arraysOverview NumPy arrays provide a fast and memory efficient alternative to Python lists. NumPy arrays are homogeneous, which means that the items in an array must be of the same type.BroadcastingIt refers to a NumPy Array’s ability to vectorize operations, so they are efficiently performed over the entire arrays.Example# Create a 2-D array nums = np.array([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]])# Use a for loop to multiply each element by 2nums_dbl1 = []for num in nums: nums_dbl1.append(num * 2)# Use a broadcasting to double element efficiently.nums_dbl2 = nums * 2Boolean indexingIt returns an array object of Boolean type, and this will be useful in filtering desired element values.Examplenums = np.array([1, 2, 3, 4, 5])# Use a for loop to filter elements greater than six.nums_filtered1 = []for num in nums: if num &gt; 2: nums_filtered1.append(num)# Use a boolean indexing to filter elements greater than six efficiently.nums_filtered2 = nums[nums &gt; 2]" }, { "title": "(KR) 함수형코딩 | 17-타임라인 조율하기", "url": "/posts/coordinating-timelines/", "categories": "CS, functional-programming", "tags": "kr, grokking-simplicity", "date": "2022-08-04 03:33:00 +0000", "snippet": "에릭 노먼드의 쏙쏙 들어오는 함수형 코딩 17장을 읽고, 정리한 페이지 동시성 기본형을 활용하여 타임라인을 관리하는 재사용 가능 객체를 만들 수 있음.Cut() 함수 타임라인을 분리하여 액션이 섞이지 않고, 순서가 보장되도록 하는 기법 실행 가능한 순서가 중요하지 않은 콜백들은 병렬로 처리 후, 컷을 적용하면 실행 속도를 개선할 수 있음.function Cut(num, callback) { // num: 기다릴 타임라인의 수, callback: 모든 것이 끝났을 때 실행할 콜백 var num_finished = 0; // 카운터 초기화 return function() { // 타임라인이 끝났을 때 호출 num_finished += 1; // 함수를 호출할 때마다 카운터가 증가 if (num_finished === num) callback(); // 마지막 타임라인이 끝났을 때 호출 };}Justonce() 함수 여러 번 호출해도 한번만 실행하도록 해주는 기법function JustOnce(action) { var alreadyCalled = false; if (alreadyCalled) // 실행한 적이 있다면 바로 종료 return; alreadyCalled = true; return action(a, b, c); // 인자와 함께 액션 호출 };}암묵적 시간 모델 vs. 명시적 시간 모델 각 언어마다 암묵적으로 실행에 관한 시간 모델(순서, 반복)을 갖고 있음. (예) 자바 스크립트의 시간 모델 (순서) 순차적 구문은 순서대로 실행 (순서) 두 타임라인에 있는 단계는 왼쪽 먼저 실행되거나, 오른쪽 먼저 실행(멀티 스레드 지원 X) (순서) 비동기 이벤트는 새로운 타임라인에서 실행 (반복) 액션은 호출될 때마다 실행 언어의 시간 모델이 원하는 것과 다를 수 있기 때문에 애플리케이션에 적합한 시간 모델을 명시적으로 만들 수 있어야 함." }, { "title": "(KR) 함수형코딩 | 15-타임라인 격리하기", "url": "/posts/isolating-timelines/", "categories": "CS, functional-programming", "tags": "kr, grokking-simplicity", "date": "2022-08-02 03:33:00 +0000", "snippet": "에릭 노먼드의 쏙쏙 들어오는 함수형 코딩 15장을 읽고, 정리한 페이지15. 타임라인 격리하기 타임라인 다이어그램(timeline diagram)은 시간에 따른 코드의 액션 순서를 시각적으로 표시한 것 소프트웨어의 동작을 이해하고, 버그를 진단하고, 예측하는데 도움을 줌.타임라인 다이어그램 그리기 액션을 확인하기: 숨어있는 액션까지 잘 찾아서 모든 액션을 타임라인에 표시해야 함. 짧고 쉽게 쓰기를 하게 해주는 연산자(++, +=)는 하나의 액션처럼 생겼으나, 실제로는 복합적인 액션 // 세 단계로 이루어진 total ++; var temp = total; // 읽기(액션) temp = temp + 1; // 더하기(계산) total = temp; // 쓰기(액션) 인자는 함수에 전달되기 전에 실행됨. // 두 단계로 이루어진 console.log(total); var temp = total; console.log(temp); 액션을 그리기: 액션은 순서대로 실행되거나, 동시에 실행될 수 있음. 두 액션이 순서대로 나타나면 하나의 타임라인에 표현함. 순서대로 실행되지만, 순서가 섞일 수 있는 코드와 그렇지 않은 경우가 존재함. 동시에 실행되거나, 순서를 예상할 수 없다면 분리된 타임라인으로 표현함. 실행 가능한 순서(possible ordering)가 여러 개인 경우 문제가 될 수 있기 때문에 이를 예상할 수 있어야 함. 여러 원인(e.g. 비동기 콜백, 프로세스, 스레드, 분산 환경)으로 코드의 실행 순서가 달라지기 때문에 이를 이해하고 있는 것이 중요함. 타임라인을 단순하게 만들기 순서가 섞이지 않는 두 액션은 하나의 박스로 합침. 타임라인 끝에서 새로운 타임라인이 하나만 생긴다면, 하나로 합침. 순서에 제약이 있는 경우 점선을 추가함. 타임라인 간 자원 공유는 최소화하기 서로 다른 타임라인에서 자원을 공유(e.g. 같은 전역변수 사용)하면 의도하지 않은 문제가 생길 수 있음. 공유하는 자원을 없애거나, 없애기 어려운 경우에는 타임라인을 조율하는 등의 방법을 사용해야 함.용어 정리 AJAX: 비동기 방식으로 데이터를 주고 받기 위해 개발된 자바스크립트 기술" }, { "title": "(KR) 함수형코딩 | 14-중첩된 데이터에 함수형 도구 사용", "url": "/posts/functional-tools-for-nested-data/", "categories": "CS, functional-programming", "tags": "kr, grokking-simplicity", "date": "2022-08-01 03:33:00 +0000", "snippet": "에릭 노먼드의 쏙쏙 들어오는 함수형 코딩 14장을 읽고, 정리한 페이지14. 중첩된 데이터에 함수형 도구 사용하기update() 해시 맵을 다루기 위한 함수형 도구로, 객체에 있는 값을 바꿀 수 있도록 해줌. 키로 대상 객체의 값을 조회, 입력 받은 함수로 값을 변경하여 리턴 function update(object, key, modify) { // 객체, 바꿀 값의 위치(키), 바꾸는 동작을 인자로 받음. \tvar value = object[key]; // 조회 \tvar newValue = modify(value); // 바꾸기 \tvar newObject = objectSet(object, key, newValue); // 설정 \treturn newObject; } nestedupdate() 재귀 함수(recursive function)를 활용하여 여러 번 중첩된 해시 맵에도 적용할 수 있는 update()를 구현 function nestedUpdate(object, keys, modify) { \tif (keys.length === 0) \t\treturn modify(object); \tvar key1 = keys[0]; \tvar restOfKeys = drop_first(keys); \treturn update(object, key1, function(value1) { \t\treturn nestedUpdate(value1, restOfKeys, modify); // 자기 자신을 호출 \t}); } 재귀 함수를 잘못 사용하여 무한 반복에 빠지지 않으려면 다음을 기억하자. 종료 조건(base case): 재귀를 멈추기 위한 조건을 명시(e.g. 배열 인자가 비었거나, 점점 값이 줄어들어 0이 됨.) 재귀 호출(recursive call): 재귀 함수는 최소 하나의 재귀 호출이 있어야 함. 종료 조건에 다가가기: 각 재귀 호출에서 최소 하나 이상의 인자가 줄어들어 한 단계씩 종료 조건에 가까워져야 함. " }, { "title": "(KR) 함수형코딩 | 12-함수형 반복", "url": "/posts/functional-iteration/", "categories": "CS, functional-programming", "tags": "kr, grokking-simplicity", "date": "2022-07-30 03:33:00 +0000", "snippet": "에릭 노먼드의 쏙쏙 들어오는 함수형 코딩 12장을 읽고, 정리한 페이지12. 함수형 반복 함수형 프로그래밍 언어에는 컬렉션 데이터를 다루는 강력한 추상 함수들이 존재함. map(), filter(), reduce()가 대표적으로, 배열을 반복해서 처리하는데 탁월하여 자주 사용됨.map() X 값이 있는 배열에 함수를 적용하여 Y 값이 있는 배열로 변환함. 리턴값인 결과 배열에 들어 있는 항목은 확인하지 않기 때문에 NULL이나 undefined가 포함될 수 있으니 주의 필요 function map(array, f) { var new_array = []; // 빈 배열 생성 forEach(array, function(element) { new_array.push(f(element)); // 원래 배열 항목에 f 함수를 적용하여 새로운 배열에 추가 }); return new_array; // 새로운 배열을 리턴} filter() 함수를 활용하여 X 값이 있는 배열 중, 특정 조건을 만족하는 X 값들만 남긴 배열을 반환함. 조건을 판단하는데 활용되는 함수를 보통 술어(predicate)라고 부름. function filter(array, f) { var new_array = []; // 빈 배열 생성 forEach(array, function(element) { if(f(element)) // 원래 배열 항목에 조건을 판단하는 f 함수를 적용 new_array.push(element); // 조건에 해당되는 항목만 결과 배열에 추가 }); return new_array; // 결과 배열을 리턴} reduce() 함수를 활용하여 X 값이 있는 배열의 항목에 누적적으로 어떤 동작을 취한 뒤, 최종 결과값을 반환함. 초깃값을 잘못 설정하면 누적의 결과가 의도하지 않게 바뀔 수 있으므로 맥락을 고려하여 신중하게 설정해야 함. (참고) 초깃값을 결정하는 방법 계산이 어떤 값에서 시작되는지(e.g. 더하기(+): 초깃값 0, 곱하기(*): 초깃값 1) 빈 배열을 사용한다면 어떤 값을 리턴할 것인지(e.g. 빈 문자열을 합친다: 빈 문자열 반환) 비즈니스 규칙은 무엇인지 특정 시점의 상태 값을 보관할 수 있기 때문에 실행 취소/복귀, 디버깅 등 다양한 곳에 활용될 수 있음. function reduce(array, init, f) { // 배열, 초깃값, 누적적인 동작을 정의한 함수 var accum = init; forEach(array, function(element) { accum = f(accum, element); // 누적 값을 계산하기 위해 현재 값과 배열의 항목을 인자로 전달 }); return accum; // 누적된 값을 리턴} " }, { "title": "(KR) 함수형코딩 | 11-일급함수 II", "url": "/posts/first-class-functions-2/", "categories": "CS, functional-programming", "tags": "kr, grokking-simplicity", "date": "2022-07-29 03:33:00 +0000", "snippet": "에릭 노먼드의 쏙쏙 들어오는 함수형 코딩 11장을 읽고, 정리한 페이지함수 본문을 콜백으로 바꾸기 함수 본문에 반복적으로 나타나는 패턴, 원칙 등을 추상화하여 별도의 함수(i.e. 콜백)로 생성하고, 인자로 전달 다음의 세 단계로 리팩토링을 해볼 수 있음. 본문과 그 앞부분, 뒷부분 확인 함수 빼내기 콜백 빼내기 고차 함수로 중복 코드를 많이 없앨 수 있으나, 지나치게 사용하면 가독성이 떨어질 수 있기 때문에 적절한 곳에 사용해야 함.(Before)function arraySet(array, idx, value) {\tvar copy = array.slice(); // 앞부분 &gt; 함수\tcopy[idx] = value; // 본문 &gt; 콜백\treturn copy; // 뒷부분 &gt; 함수}function push(array, elem) {\tvar copy = array.slice();\tcopy.push(elem);\treturn copy;}(After)function arraySet(array, idx, value) {\treturn withArrayCopy(array, function(copy) {\t\tcopy[idx] = value;});}function push(array, elem) {\treturn withArrayCopy(array, function(copy) {\t\tcopy.push(elem);});}function withArrayCopy(array, modify) { // modify: 여러 변경 동작에 대한 일반적인 이름\tvar copy = array.slice();\tmodify(copy);\treturn copy;}" }, { "title": "(KR) 함수형코딩 | 10-일급함수 I", "url": "/posts/first-class-functions-1/", "categories": "CS, functional-programming", "tags": "kr, grokking-simplicity", "date": "2022-07-28 03:33:00 +0000", "snippet": "에릭 노먼드의 쏙쏙 들어오는 함수형 코딩 10장을 읽고, 정리한 페이지 중복을 없애 추상화를 잘할 수 있는 리팩토링 기법 두 가지를 소개함.암묵적 인자를 드러내기 함수 이름에서 구현의 차이점이 드러나는 것을 제외하고 반복적인 패턴이 있다면 암묵적 인자가 존재한다고 할 수 있음. 다음의 네 단계를 통해 암묵적 인자를 명시적으로 변경하는 리팩토링을 해볼 수 있음. 함수 이름에 있는 암묵적 인자를 확인 명시적인 인자를 추가 함수 본문에 하드 코딩된 값을 새로운 인자로 변경 함수를 호출하는 곳을 수정 (Before)function setPriceByName(cart, name, price) {\tvar item = cart[name];\tvar newItem = objectSet(item, 'price', price);\tvar newCart = objectSet(cart, name, newItem);\treturn newCart;}function setQuantityByName(cart, name, quant) {\tvar item = cart[name];\tvar newItem = objectSet(item, 'quantity', quant);\tvar newCart = objectSet(cart, name, newItem);\treturn newCart;}function setShippingByName(cart, name, ship) {\tvar item = cart[name];\tvar newItem = objectSet(item, 'shipping', ship);\tvar newCart = objectSet(cart, name, newItem);\treturn newCart;}(After)function setFieldByName(cart, name, field, value) {\tvar item = cart[name];\tvar newItem = objectSet(item, field, value);\tvar newCart = objectSet(cart, name, newItem);\treturn newCart;} 일급인 것과 일급이 아닌 것 일급(first-class) 객체는 다음의 네 가지 특징을 가짐. 변수에 할당 함수의 인자로 넘기기 함수의 리턴값으로 받기 배열이나 객체에 담기 특히 다른 함수를 인자로 받거나, 리턴 값으로 함수를 리턴할 수 있는 함수는 고차 함수(higher-order function)라고 부름. 일급이 아닌 객체들(e.g. 수식 연산자, 반복문 등)을 일급으로 바꾸는 방법을 아는 것이 중요함.용어 정리 함수를 정의하는 방법 전역으로 정의하기: 함수를 전역적으로 정의하고, 이름 붙이기 지역적으로 정의하기: 함수를 지역 범위 안에서 정의하고, 이름 붙이기 인라인으로 정의하기(익명 함수): 함수를 사용하는 곳에서 바로 정의 콜백(callback): 나중에 호출하기 위해 인자로 전달하는 함수" }, { "title": "(KR) 함수형코딩 | 07-불변성 유지하기 II", "url": "/posts/staying-immutable-with-untrusted-code/", "categories": "CS, functional-programming", "tags": "kr, grokking-simplicity", "date": "2022-07-25 03:33:00 +0000", "snippet": "에릭 노먼드의 쏙쏙 들어오는 함수형 코딩 7장을 읽고, 정리한 페이지07. 신뢰할 수 없는 코드를 쓰면서 불변성 지키기방어적 복사(defensive copying) 세부적인 동작을 파악하거나, 통제하기 어려운 코드를 사용하면 카피 온 라이트 패턴을 적용하기 어려움. 방어적 복사는 깊은 복사 방식을 활용하여 데이터가 바뀌는 것을 완벽히 방지하는 원칙으로 다음의 방법을 활용함. 데이터가 안전한 코드(i.e. 데이터의 불변성이 지켜지는 코드)에서 나갈 때 복사하기 데이터가 바뀌지 않도록 깊은 복사본을 생성 신뢰할 수 없는 코드로 복사본을 전달 안전한 코드로 데이터가 들어올 때 복사하기 변경될 수 있는 데이터가 들어오면 바로 깊은 복사본을 생성하여 안전한 코드로 전달 복사본을 안전한 코드에서 사용 function add_item_to_cart(name, price) { var item = make_cart_item(name, price); shopping_cart = add_item(shopping_cart, item); var total = calc_total(shopping_cart); set_cart_total_dom(total); update_shipping_icons(shopping_cart); var cart_copy = deepCopy(shopping_cart); // (비안전지대)로 넘기기 전에 복사 black_friday_promotion(cart_copy); shopping_cart = deepCopy(cart_copy); // (안전지대)로 들어오기 전에 복사} 방어적 복사에서 활용되는 깊은 복사는 원본의 모든 것(중첩된 객체, 배열 등)을 복사하여 비용이 많이 들기 때문에 카피 온 라이트를 적용하기 어려운 경우에만 사용하는 것이 좋음.용어 정리 레거시 코드(legacy code): 오래전에 만든 것으로, 지금 당장 고칠 수 없어서 그대로 사용해야 하는 코드 얕은 복사(shallow copy): 데이터 구조의 최상위 단계만 복사 깊은 복사(deep copy): 모든 계층에 있는 중첩된 데이터 구조를 복사" }, { "title": "(KR) 함수형코딩 | 06-불변성 유지하기 I", "url": "/posts/staying-immutable-in-a-mutable-language/", "categories": "CS, functional-programming", "tags": "kr, grokking-simplicity", "date": "2022-07-24 03:33:00 +0000", "snippet": "에릭 노먼드의 쏙쏙 들어오는 함수형 코딩 6장을 읽고, 정리한 페이지06. 변경 가능한 데이터 구조를 가진 언어에서 불변성 유지하기카피 온 라이트란? 의도하지 않게 데이터를 변경하는 것(mutable operations)을 막기 위한 방법으로, 아래의 세 단계로 구성됨. 복사본 만들기(make a copy) 복사본 변경하기(modify the copy) 복사본 리턴하기(return the copy) // 배열에 대한 카피 온 라이트function add_element_last(array, elem) { var new_array = array.slice(); // 1) 복사본 만들기 new_array.push(elem); // 2) 복사본 변경하기: 배열에 원소 추가 return new_array; // 3) 복사본 리턴하기}// 객체에 대한 카피 온 라이트function setPrice(item, new_price) { var item_copy = Object.assign({}, item); // 1) 복사본 만들기 item_copy.price = new_price; // 2) 복사본 변경하기 return item_copy; // 3) 복사본 리턴하기} 함수형 프로그래밍에서 카피 온 라이트는 자주 사용되기 때문에 유틸리티 함수로 생성해두면 편리함.용어 정리 중첩 데이터(nested data): 데이터 구조 안에 또 다른 데이터 구조가 있는 형태로 된 데이터 핸들러(handler): 특정 이벤트를 처리하도록 생성된 함수를 지칭 (e.g., event handler, exception handler, …) 구조적 공유(structural sharing): 두 중첩된 데이터 구조에서 안쪽 데이터가 같은 데이터를 참조함. 보일러 플레이트 코드(boilerplate code): 일종의 템플릿처럼 기본이 되는 골격 등을 정의한 코드" }, { "title": "(KR) 함수형코딩 | 05-더 좋은 액션 만들기", "url": "/posts/improving-the-design-of-actions/", "categories": "CS, functional-programming", "tags": "kr, grokking-simplicity", "date": "2022-07-23 03:33:00 +0000", "snippet": "에릭 노먼드의 쏙쏙 들어오는 함수형 코딩 5장을 읽고, 정리한 페이지05. 더 좋은 액션 만들기 더 좋은 액션을 만들기 위해서는 암묵적 입출력을 줄이고, 함수를 최대한 작게 구성해야 함.적을수록 좋은 암묵적 입출력 암묵적 입출력이 있는 함수는 의도하지 않은 결과를 발생시킬 수 있어 테스트가 쉽지 않음. 암묵적 입출력을 명시적으로 바꿔 모듈화된 컴포넌트로 만들면 테스트 용이성, 재사용성을 높일 수 있음.암묵적 입출력 줄이기(Before)function update_shipping_icons() { var buttons = get_buy_buttons_dom(); for (var i = 0; i &lt; buttons.length; i++) { var button = buttons[i]; var item = button.item; var new_cart = add_item(shopping_cart, item.name, item.price); if (gets_free_shipping(new_cart)) { button.show_free_shipping_icon(); else button.hide_free_shipping_icon(); } }}// 함수 호출부function calc_cart_total() { shopping_cart_total = calc_total(shopping_cart); set_cart_total_dom(); update_shipping_icons(); update_tax_dom();}(After)function update_shipping_icons() { var buttons = get_buy_buttons_dom(); for (var i = 0; i &lt; buttons.length; i++) { var button = buttons[i]; var item = button.item; var new_cart = add_item(shopping_cart, item.name, item.price); if (gets_free_shipping(new_cart)) { button.show_free_shipping_icon(); else button.hide_free_shipping_icon(); } }}// 함수 호출부function calc_cart_total() { shopping_cart_total = calc_total(shopping_cart); set_cart_total_dom(); update_shipping_icons(); update_tax_dom();}설계는 엉켜있는 코드를 푸는 것 작은 함수 단위로 코드를 잘 분리하면 다음의 이유에서 좋은 설계라고 할 수 있음. 높은 재사용성 쉬운 유지보수 테스트 용이성 증가 함수가 작아지면(e.g. 각 함수가 하나의 일만 한다.) 개념을 중심으로 쉽게 구성할 수 있음.함수를 더 작은 함수로 분리하기 함수가 하는 일을 나열 후, 분류해보고 하나의 일만 하도록 변경(Before)function add_item(cart, name, price) { var new_cart = cart.slice(); // 1) 배열 복사 new_cart.push({ // 2) 추가할 item 객체 생성 name: name, // 3) 배열 복사본에 item 추가 price: price }); return new_cart; // 4) 배열 복사본 리턴}(After)// 1. 추가할 item 객체 생성 분리function make_cart_item(name, price) { return { name: name, price: price };}function add_item(cart, item) { var new_cart = cart.slice(); // 1) 배열 복사 new_cart.push(item); return new_cart; // 4) 배열 복사본 리턴}// (참고) 함수 호출부 변경add_item(shopping_cart, make_cart_item(\"shoes\", 3.5));재사용이 가능한 (일반적인) 함수로 변환 범용적으로 사용될 수 있는 함수를 일반적인 이름으로 만들면, 여러 상황에서 재사용 가능한 유틸리티 함수가 될 수 있음.(Before)function make_cart_item(name, price) { return { name: name, price: price };}function add_item(cart, item) { var new_cart = cart.slice(); // 1) 배열 복사 new_cart.push(item); return new_cart; // 4) 배열 복사본 리턴}(After)function make_cart_item(name, price) { return { name: name, price: price };}// 범용적인 함수로 변환function add_element_last(array, elem) { var new_array = array.slice(); // 1) 배열 복사 new_array.push(elem); return new_array; // 4) 배열 복사본 리턴}용어 정리 함수 시그니처(function signature): 함수명, 매개변수, 반환 결과 타입의 조합 유틸리티 함수(utility function): 여러 가지 계산과 처리를 대신하는 일반 함수. 높은 재사용성이 특징." }, { "title": "(KR) 함수형코딩 | 04-액션에서 계산 빼내기", "url": "/posts/extracting-calculations-from-actions/", "categories": "CS, functional-programming", "tags": "kr, grokking-simplicity", "date": "2022-07-22 03:33:00 +0000", "snippet": "에릭 노먼드의 쏙쏙 들어오는 함수형 코딩 4장을 읽고, 정리한 페이지04. 액션에서 계산 빼내기 액션에서 계산을 빼내는 리팩토링을 하면, 테스트하기 쉽고 재사용성이 좋아진다!액션 vs. 계산 구분 함수는 입력(계산을 하기 위한 외부 정보)을 사용하여 출력(함수 밖으로 나오는 정보나 어떤 동작/효과)을 반환함. 함수에 명시적으로 주어진 입력(인자)과 출력(리턴값) 외의 모든 것은 암묵적인 입출력으로, 부수 효과에 해당함. 함수에 암묵적 입출력이 존재하면 액션, 존재하지 않으면 계산이 된다.액션에서 계산 추출서브루틴 추출하기 입력값으로 출력값을 만드는 계산에 해당되는 부분을 액션 함수로부터 빼내 별도의 함수로 생성 새로 생성한 함수 calc_total()은 기계적으로 분리만 된 것으로, 암묵적 입출력이 아직 존재하기 때문에 액션에 해당됨.(Before)var shopping_cart = [];var shopping_cart_total = 0;function calc_cart_total() { // 0) 장바구니에 담겨 있는 제품의 금액 계산 shopping_cart_total = 0; for(var i = 0; i &lt; shopping_cart.length; i ++) { var item = shopping_cart[i]; shopping_cart_total += item.price; } // 1) DOM 업데이트 set_cart_total_dom(); // 2) 배송 아이콘 업데이트 update_shipping_icons(); // 3) 세금 재계산 update_tax_dom();}(After)var shopping_cart = [];var shopping_cart_total = 0;function calc_cart_total() { // 0) 새로 만든 함수 호출 calc_total(); // 1) DOM 업데이트 set_cart_total_dom(); // 2) 배송 아이콘 업데이트 update_shipping_icons(); // 3) 세금 재계산 update_tax_dom();}function calc_total() { shopping_cart_total = 0; for(var i = 0; i &lt; shopping_cart.length; i ++) { var item = shopping_cart[i]; shopping_cart_total += item.price; }}입력값은 인자로, 출력값은 리턴값으로 변경 전역변수를 읽고, 변경하는 것은 암묵적 입출력이 존재한다는 의미 전역변수 대신 지역변수를 사용하도록 바꾸고, 지역변숫값을 리턴하도록 변경해야 함.(Before)var shopping_cart = [];var shopping_cart_total = 0;function calc_cart_total() { // 0) 장바구니에 담겨 있는 제품의 금액 계산 shopping_cart_total = 0; // (i) 암묵적 출력 for(var i = 0; i &lt; shopping_cart.length; i ++) { // (ii) 암묵적 입력 var item = shopping_cart[i]; shopping_cart_total += item.price; // (iii) 암묵적 출력 } // 1) DOM 업데이트 set_cart_total_dom(); // 2) 배송 아이콘 업데이트 update_shipping_icons(); // 3) 세금 재계산 update_tax_dom();}(After)var shopping_cart = [];var shopping_cart_total = 0;function calc_cart_total() { // 0) 장바구니에 담겨 있는 제품의 금액 계산 calc_total(shopping_cart); // shopping_cart를 인자로 전달 // 1) DOM 업데이트 set_cart_total_dom(); // 2) 배송 아이콘 업데이트 update_shipping_icons(); // 3) 세금 재계산 update_tax_dom();}function calc_total(cart) { // 전역변수 대신 인자를 만들어 사용 var total = 0; for(var i = 0; i &lt; cart.length; i ++) { var item = cart[i]; total += item.price; } return total;}용어 정리 리팩토링(refactoring): 코드의 동작을 유지하되, 효율성과 유지 보수성을 높이는 작업 DOM(Document Object Model): 웹브라우저 안에 있는 HTML 페이지를 메모리상에 표현한 것 비즈니스 규칙(business rules): 제품이 따라야 할 원칙. 지켜야 할 정부 법규, 산업 표준, 내사 규칙, 알고리즘 등이 해당됨. 테스트 커버리지(test coverage): 프로그램의 전체 동작 중에서 테스트로 검사한 범위 카피 온 라이트(copy-on-write): 어떤 값을 바꿀 때 그 값을 복사해서 바꾸는 방법, 불변성을 구현하는 방법 전역 변수(global variable): 프로그램의 모든 지점에서 호출하고, 사용할 수 있는 변수. 프로그램이 시작될 때 메모리가 할당되고 끝까지 유지되기 때문에 많이 사용할수록 가용 메모리가 줄어듦. 지역 변수(local variable): 그 변수가 선언된 함수 혹은 블록 내에서만 사용할 수 있는 변수" }, { "title": "(KR) 함수형코딩 | 03-액션과 계산, 데이터의 차이를 알기", "url": "/posts/distinguishing-acd/", "categories": "CS, functional-programming", "tags": "kr, grokking-simplicity", "date": "2022-07-21 03:33:00 +0000", "snippet": "에릭 노먼드의 쏙쏙 들어오는 함수형 코딩 3장을 읽고, 정리한 페이지03. 액션과 계산, 데이터의 차이를 알기 개발 과정 전반(설계 - 코딩 - 코드 리뷰)에 걸쳐 액션, 계산, 데이터를 구분하는 기술을 적용할 수 있음.설계 Tips 하나의 액션처럼 보이는 것들을 액션, 계산, 데이터로 세분화하는 연습이 필요함. 계산 단계는 머릿속에서 자동으로 이뤄져 찾기 어려움. 다음의 두 질문을 의식적으로 생각하면 계산을 찾는데 도움이 됨. 어떤 단계에서 무엇인가 “결정”해야 할 것이 있나? 무엇인가 “계획”해서 방법을 찾아야 할 것이 있나? 코딩 Tips 제약이 많은 것부터 먼저 구현하는 것이 편리함. (i.e. 데이터 &gt; 계산 &gt; 함수)코드 리뷰 Tips 액션을 포함하고 있는 함수도 액션이기 때문에 잘못 구성하면 코드 전체가 액션으로 바뀔 수 있음. 액션은 코드에서 다양한 형태로 나타나기 때문에 숨겨진 액션이 있을 수 있음. 함수 호출 메서드 호출 생성자 표현식(변수/속성/배열 참조) 상태(값 할당, 속성 삭제) 데이터, 계산, 액션 더 자세히 알아보기데이터 (구현) 기본 데이터 타입(built-in data types)으로 구현하며, 특정 언어에서는 더 정교한 방법으로 생성 가능함. (의미) 데이터 구조는 의미를 담을 수 있는 수단. (e.g. 목록의 순서가 중요하다면, 순서 보장 가능한 데이터 구조 사용) (장단점) 전송이 편리하고, 서로 비교가 가능하며 자유로운 해석이 가능하다는 장점이 있으나, 해석이 없다면 쓸모가 없음.계산 (구현) 함수 형태로 구현 (의미) 입력값을 출력값으로 만드는 연산을 담을 수 있음. (장단점) 테스트와 기계적인 분석이 쉬우며, 조합하기 좋지만, 실행하기 전에는 실제 어떤 일이 발생할지 알기 어려움.액션 (구현) 함수 형태로 구현 (의미) 외부에 영향을 줄 수 있으므로(i.e. 부수 효과가 있으므로) 어떤 일을 하는지 아는 것이 중요함. (장단점) 다루기 어렵지만, 소프트웨어를 실행하는 가장 중요한 이유 액션을 잘 다루는 Tips 가능한 액션을 적게 사용하기: 액션은 가급적 계산, 데이터로 변경 가능한 액션을 작게 만들기: 액션에서 액션과 관련 없는 코드는 모두 제거 함수형 프로그래밍의 기술들로 외부 세계와의 상호작용과 호출 시점에 의존하는 것을 제한 " }, { "title": "(KR) 함수형코딩 | 02-현실에서의 함수형 사고", "url": "/posts/functional-thinking-in-action/", "categories": "CS, functional-programming", "tags": "kr, grokking-simplicity", "date": "2022-07-20 03:33:00 +0000", "snippet": "에릭 노먼드의 쏙쏙 들어오는 함수형 코딩 2장을 읽고, 정리한 페이지02. 현실에서의 함수형 사고변경 가능성에 따라 코드 나누기계층화 설계 맛보기 계층화 설계(stratified design): 변경 가능성에 따라 계층을 두어 코드를 구분하는 것 계층 구조로 소프트웨어를 만들면 테스트, 재사용, 유지보수가 쉽다는 장점이 있음. 일반적으로 비즈니스 규칙, 도메인 규칙, 기술 스택 계층으로 나눔. 분산 시스템을 타임라인으로 시각화하기 타임라인 다이어그램을 활용하면, 시간에 따라 진행되는 작업을 쉽게 모델링 할 수 있음. 액션을 수행하는 주체가 하나라면 간단하지만, 여럿으로 바뀌면(i.e. 분산 시스템) 각자의 타임라인이 생기기 때문에 이를 조정하는 시스템이 필요함. 타임라인을 서로 맞추지 않은 시스템은 예측 불가능한 순서로 실행 타임라인 커팅을 활용하면 여러 타임라인이 동시에 진행될 때 서로 순서를 맞출 수 있음. " }, { "title": "(KR) 함수형코딩 | 01-함수형 프로그래밍은 무엇인가?", "url": "/posts/welcome-to-grokking-simplicity/", "categories": "CS, functional-programming", "tags": "kr, grokking-simplicity", "date": "2022-07-19 03:33:00 +0000", "snippet": "에릭 노먼드의 쏙쏙 들어오는 함수형 코딩 1장을 읽고, 정리한 페이지입니다.함수형 프로그래밍은 무엇인가?함수형 프로그래밍의 정의 수학 함수를 사용하고 부수 효과를 피하는 것이 특징인 프로그래밍 패러다임 부수 효과(side effect): 함수가 결괏값을 반환하는 것 외에 하는 모든 행동 부수 효과 없이 순수 함수만 사용하는 프로그래밍 스타일 순수 함수(pure function): 인자에만 의존하고, 부수 효과가 없는 함수 부수 효과가 있는 (순수하지 않은) 함수는 꼭 필요하지만, 원하지 않는 결과를 만들 수도 있기 때문에 사용 시 주의가 필요함.액션 vs. 계산 vs. 데이터 함수형 프로그래밍에서는 코드를 액션, 계산, 데이터 세 가지로 구분함. 각각의 장단점이 다르기 때문에 이를 잘 알고, 적절하게 쓰는 것이 중요함. 일반적으로 데이터 &gt; 계산 &gt; 액션 순으로 사용하기 쉬움. 구분 특징 예시 액션(actions) 실행 시점이나 횟수에 의존하기 때문에 신중하게 사용해야 함. sendEmail(to, from, subject, body): 이메일 전송 saveUserDB(user) : 사용자 정보를 데이터 베이스에 저장 getCurrentTime() : 현재 시간 반환 계산(calculations) 입력값을 계산해 출력하는 것 언제 호출해도 항상 같은 값을 반환함. sum(numbers): 입력 받은 숫자를 모두 더한 결과 반환 string_length(str): 입력 받은 문자열의 길이 반환 데이터(data) 이벤트에 대한 사실을 기록한 것 {\"firstname\": \"Eric\", \"lastname\": \"Normand\"}: 사람에 대한 정보 [1, 10, 2, 45, 3, 98]: 숫자 리스트 왜 함수형 프로그램이 필요한가? 함수형 프로그래밍은 분산 시스템에 잘 어울림. 여러 컴퓨터가 통신하는 분산 시스템의 경우, 소프트웨어가 복잡해짐. (e.g. 처리해야 할 메시지 순서 변경, 중복, 유실) 실행 시점이나 횟수에 의존하는 코드를 없애면 분산 시스템에서 생기는 여러 문제를 해결할 수 있음. 불가피하게 액션을 사용하는 경우, 함수형 프로그래밍이 제시하는 액션을 다루는 기술을 활용하면 도움이 됨. " } ]
